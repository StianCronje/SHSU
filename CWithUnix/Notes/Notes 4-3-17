Notes 4/3/17
Special Programming
Burris

/* 
In file NamedPipeServer1.c to be used with NamedPipeClient1.c. 

Code illustrating use of a “named pipe” to facilitate communications between two completely separate system processes.  Run the Server and Client from two terminals (command prompts) as follows: 

From terminal window one:
$./NamedPipeServer1

From terminal window two:
$./NamedPipeClient1

Alternately, start the server as a background task followed by the client in the same window.

$./NamedPipeServer1&
$./NamedPipeClient1

Multiple clients may be started.  Beware race conditions especially under two-way communications with multiple processes.  Race conditions can lead to deadlock.

*/


#include <stdio.h>
#include <stdlib.h>
#include <sys/stat.h>
#include <unistd.h>
#include <string.h>
#include <linux/stat.h>

#define FIFO_FILE  "MYFIFO"  //First-in-first-out disk file.
                             //You may include a path such as /tmp/MYFIFO.
                             //The default file path is current directory.
int main(void) {
        FILE *fpoint;
        char readbuffer[80];
        int again = 1;  //flag to repeat blocking read.

        /* Create the FIFO file if it does not exist */
        umask(0);   //Set up user file mask.  Default permission typically
                            //0022 (022) or 0002 (002).  "0" gives all rights to
                            //user, groups, and others. 
       
	//PROTOTYPE: int mknod( char  *pathname, mode_t  mode, dev_t  dev);
	//created as a FIFO file. The requested file permissions below are
	// ``0666'', although they are affected by the umask setting as
	// follows: final_umask = requested_permissions & ~original_umask.

	//The umask( ) system call is commonly used to temporarily zap 
	//the umask value as follows: 
  	//umask(0);
  	//mknod("/tmp/MYFIFO", S_IFIFO|0666, 0);
	//The third argument to mknod( ) is ignored unless
	//creating a device file. In that instance, it should specify the
	// major and minor numbers of the device file. 

	mknod(FIFO_FILE,  S_IFIFO|0666,  0);


        while( again )
        {
                fpoint = fopen(FIFO_FILE, "r");   //Open named pipe, reader blocked
                fgets(readbuffer, 80, fpoint);           //till writer opens pipe for rendezvous.
                printf("Received string: %s\n", readbuffer);
                fclose(fpoint);                                                  //release named pipe.
                if( strcmp(readbuffer, "Stop") == 0) again = 0;
        }

        return(0);
}

TEST REVIEW
1/2 seq search
struct
struct array
relative address array
multidim array
lab3
    some info on test
    (Newton)
T1 & T2 funcs